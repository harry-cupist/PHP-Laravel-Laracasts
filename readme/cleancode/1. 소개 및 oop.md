## 소개 및 OOP

원하는 바

- 돌아가는 코드 - 읽을 수 있는 코드
- IDE를 활용한 레거시 리팩토링
- TDD를 이용한 새로운 기능 개발
- OOP/SOLID에 기반한 설계

OOP 원칙



#### 1. Why Clean Code

SW는 한번 작성되면 최소 10번 이상 읽힌다. 그래서 대충 돌아만가게 작성하면 안되고 읽기 편하게 작성해야 한다. 기계가 이해하는 코드는 누구나 작성할 수 있음. 그러나 인간이 이해할 수 있는 코드는 잘 훈련된 소프트웨어 엔지니어만 작성할 수 있음.



#### 2. Why OOP

절차지향: 중간에 데이터가 있음. 그 데이터를 가지고 동작하는 함수(프로시져)가 있음. 함수들이 데이터를 공유해서 사용함. 데이터의 변경이 생기면, 굉장히 많은 부분(프로시져 등)에 변경이 발생함

객체지향: 데이터를 공유해서 사용하지 않음. 데이터를 사용하는 기능들은 객체안에 매핑되어 있음. 데이터에 변경이 생기면 특정 객체만 영향을 미침(cohesion;응집도. 밖에 있는 데이터들은 영향을 미치지 않음)

- 데이터와 코드는 캡슐화 되어야함. 
- 데이터와 그 데이터를 조작하는 코드의 변경은 외부의 영향을 미치면 안됨. (인터페이스)
- 외부에 노출된 인터페이스만 변경되지 않는다면 프로시저를 실행하는데 필요한 만큼 데이터만 가짐

단순한 시스템은 쉬운 절차 지향이 권장됨 (그러나 단순한 시스템이 현실적으로 존재할까?) 복잡하거나 요구사항 변화가 발생할 시스템은 객체 지향이 권장된다. 절차지향이 처음에 쉬울지도 모르나 시간이 지나먼 수정하기 어려운 구조가 됨.



#### 3. Object / Role / Responsibility

객체/클래스의 이름: "무엇"으로 정의 해야함 ("어떻게"로 정의하면 안됨) - `RequestParser` vs `JsonRequestParser`

역할은 관련된 책임의 집합

- Role : 시스템 사용자들, 게시판의 경우 글쓰기 사용자, 운영자, 비회원 - 사용하는 기능으로 그루핑되는 주요한 유저의 그룹이 바로 역할
- Responsibilty : 그 역할을 만족시키기 위해 시스템에서 제공하는 연관되는 기능. (예. 어떤 특정 유저를 만족시키기 위한 어떤 일련의 행위)
- 역할이 책임보다 좀 더 거시저적인 개념. 객체는 역할을 가짐



#### 4. 객체지향 설계 과정

1) 기능을 제공할 객체 후보 선별: 내부에서 필요한 데이터 선별,  클래스 다이어그램, 정적 설계

- 예) FlowController - FileReader / Encrypter / FileWriter

2) 객체 간 메시지 흐름 연결: 커뮤니케이션 다이어그램, 시퀀스 다이어그램, 동적 설계

- 예) :FlowController(비즈니스로직)
  - 1: read(): byte [] -> :FileReader(기능)
  - 2: encrypt(bytes: byte []): byte [] -> Encrypter
  - 3: write(bytes: byte[]) -> :FileWriter

1)와 2)를 반복하는 것이 객체지향 설계 과정임.



#### 5. Encapsulation (캡슐화)

  내부의 변화가 외부에 영향을 주면 안됨. (객체 지향의 기본)

Tell, Don't Ask. 데이터를 요청해서 변경하고 저장하라고 하지 말고 무슨 기능을 실행하라. 데이터를 잘 알고 있는 객체에게 기능을 수행하라고 하라. Encapsulation이 유지되어 변경에 영향을 안받게 됨.

- Law of Demeter

Command Vs Query: Command Query Seperation(CQS). 

- Command: 메서드로 내부의 상태를 변경시킴(Tell)
- Query: 상태 변경 없이 결과값만 줌(Ask)
- 두개의 메서드는 합쳐져 있으면 안됨. 상태를 두개이상 변경하는 것도 지양. 



#### 6. Polymorphism (다형성)

한 객체가 여러가지(Poly) 모습/타입(morph)을 가질 수 있음

- Java: 구현 상속, 인터페이스 상속



#### 7. Abstraction (추상화)

공통된 데이터나 프로세스를 제공하는 객체들을 하나의 타입(인터페이스)으로 추상화 하는 것. 객체 지향의 핵심은 의존성 관리를 통해 High level logic을 Low level detail로 부터 보호하는 것. 이를 통해 Low level detail(예. 로그 수집 방법)의 변경이 발생해도 High level logic(collector collect하고 iterate하며 처리하는)는 보호됨. 

Programming to Interface: 구체적인 클래스를 보지 말고 인터페이스를 보고 개발하라.

개발자들은 습성상 상세한 구현에 빠지다보면 상위 수준의 설계를 놓치기 쉬움. 추상화를 통해서 상위 수준에서의 설계를 하는데 도움을 얻을 수 있음.